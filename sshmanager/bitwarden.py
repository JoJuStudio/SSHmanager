"""Minimal Bitwarden/Vaultwarden API wrapper used by SSH Manager.

The API integration is intentionally lightweight. The application only needs to
fetch items from a specific folder and therefore authenticates using an API
access token generated by the Bitwarden web vault.

Due to the limited scope, only a subset of the API is implemented.
"""

from __future__ import annotations

import base64
import json
import logging
import hashlib
from typing import Any, Optional, List, Tuple
from urllib import request, error, parse
from uuid import uuid4

from argon2.low_level import Type, hash_secret_raw

from .models import Connection


_DEFAULT_SERVER = "https://vault.bitwarden.com"
_token: Optional[str] = None
_server: str = _DEFAULT_SERVER
# Store the most recent login error message so the UI can present it
_last_error: Optional[str] = None


def _prelogin(email: str) -> Optional[Tuple[int, int]]:
    """Retrieve KDF parameters for the account."""
    global _last_error
    url = f"{_server}/identity/accounts/prelogin"
    data = json.dumps({"email": email}).encode()
    req = request.Request(url, data=data)
    req.add_header("Content-Type", "application/json")
    try:
        with request.urlopen(req) as resp:
            info = json.loads(resp.read().decode())
    except error.HTTPError as exc:
        body = exc.read().decode()
        try:
            resp_data = json.loads(body)
        except Exception:
            resp_data = {}
        msg = resp_data.get("error") or body.strip()
        if msg:
            _last_error = f"HTTP {exc.code}: {msg}"
        else:
            _last_error = f"HTTP {exc.code}: {exc.reason}"
        logging.error(
            "Bitwarden prelogin HTTP error %s %s: %s", exc.code, exc.reason, msg
        )
        return None
    except error.URLError as exc:
        _last_error = f"Network error: {exc.reason}"
        logging.error("Bitwarden prelogin failed for %s: %s", _server, exc)
        return None
    kdf = info.get("Kdf")
    iterations = info.get("KdfIterations")
    if kdf is None or iterations is None:
        # Newer Vaultwarden releases return lowercase field names
        info_l = {k.lower(): v for k, v in info.items()}
        if kdf is None:
            kdf = info_l.get("kdf")
        if iterations is None:
            iterations = (
                info_l.get("kdfiterations")
                or info_l.get("kdf_iterations")
            )
    if kdf is None or iterations is None:
        _last_error = "Prelogin response missing fields"
        logging.error("Bitwarden prelogin response missing fields: %s", info)
        return None
    return int(kdf), int(iterations)


def _hash_password(email: str, password: str, kdf: int, iterations: int) -> str:
    email_bytes = email.lower().encode()
    pw_bytes = password.encode()
    if kdf == 0:
        dk = hashlib.pbkdf2_hmac("sha256", pw_bytes, email_bytes, iterations)
    elif kdf == 1:
        dk = hash_secret_raw(
            pw_bytes,
            email_bytes,
            time_cost=iterations,
            memory_cost=64 * 1024,
            parallelism=4,
            hash_len=32,
            type=Type.ID,
        )
    else:
        raise ValueError(f"Unsupported KDF: {kdf}")
    return base64.b64encode(dk).decode()


def login(
    email: str,
    password: str,
    server: str | None = None,
    device_name: str | None = None,
    device_identifier: str | None = None,
) -> bool:
    """Authenticate using email and master password.

    Parameters
    ----------
    email:
        Account email address.
    password:
        Master password used to unlock the vault.
    server:
        Base URL of the Vaultwarden instance. Defaults to the official
        Bitwarden cloud.
    device_name:
        Optional human readable name for this client. Defaults to
        "SSH Manager".
    device_identifier:
        Optional unique identifier for the device. A random value is
        generated when omitted.
    """

    global _token, _server, _last_error
    _last_error = None
    _token = None
    if not email or not password:
        _last_error = "Email and password are required"
        return False
    _server = server or _DEFAULT_SERVER
    device_id = device_identifier or uuid4().hex

    kdf_info = _prelogin(email)
    if not kdf_info:
        _last_error = _last_error or "Prelogin failed"
        return False
    kdf, iterations = kdf_info

    try:
        password_hash = _hash_password(email, password, kdf, iterations)
    except ValueError as exc:
        _last_error = str(exc)
        logging.error("Bitwarden password hashing failed: %s", exc)
        return False

    data = parse.urlencode(
        {
            "grant_type": "password",
            "username": email,
            "password": password_hash,
            "scope": "api offline_access",
            "client_id": "desktop",
            "deviceType": 8,
            "deviceIdentifier": device_id,
            "deviceName": device_name or "SSH Manager",
        }
    ).encode()
    url = f"{_server}/identity/connect/token"
    req = request.Request(url, data=data)
    req.add_header("Content-Type", "application/x-www-form-urlencoded")
    try:
        with request.urlopen(req) as resp:
            resp_data = json.loads(resp.read().decode())
    except error.HTTPError as exc:
        body = exc.read().decode()
        try:
            resp_data = json.loads(body)
        except Exception:
            resp_data = {}
        msg = resp_data.get("error_description") or body.strip()
        if msg:
            _last_error = f"HTTP {exc.code}: {msg}"
        else:
            _last_error = f"HTTP {exc.code}: {exc.reason}"
        logging.error(
            "Bitwarden login HTTP error %s %s: %s", exc.code, exc.reason, msg
        )
        return False
    except error.URLError as exc:
        _last_error = f"Network error: {exc.reason}"
        logging.error("Bitwarden login failed for %s: %s", _server, exc)
        return False
    token = resp_data.get("access_token")
    if not token:
        _last_error = resp_data.get("error_description") or "Invalid credentials"
        logging.error("Bitwarden login response missing access_token")
        return False
    _token = token
    return True


def get_status() -> str:
    """Return ``"unlocked"`` if a token is available, otherwise
    ``"unauthenticated"``."""

    return "unlocked" if _token else "unauthenticated"


def is_unlocked() -> bool:
    return _token is not None


def get_last_error() -> Optional[str]:
    """Return the most recent error message from :func:`login`."""
    return _last_error


def _api_request(path: str) -> Any:
    if _token is None:
        raise RuntimeError("Bitwarden API token not set")
    url = f"{_server}/api{path}"
    req = request.Request(url)
    req.add_header("Authorization", f"Bearer {_token}")
    try:
        with request.urlopen(req) as resp:
            return json.loads(resp.read().decode())
    except error.URLError as exc:
        logging.error("Bitwarden API request failed: %s", exc)
        return None


def _get_ssh_folder_id() -> Optional[str]:
    data = _api_request("/folders")
    if not data:
        return None
    for folder in data.get("data", []):
        if folder.get("name") == "SSH":
            return folder.get("id")
    return None


def fetch_credentials(item: str) -> Optional[dict[str, Any]]:
    """Fetch connection configuration from a Bitwarden item."""
    if not is_unlocked():
        return None
    data = _api_request(f"/ciphers/{parse.quote(item)}")
    if not data:
        return None
    notes = data.get("notes") or data.get("notesPlain", "")
    if not notes:
        return None
    try:
        return json.loads(notes)
    except json.JSONDecodeError as exc:
        logging.error("Config in Bitwarden notes is invalid JSON: %s", exc)
        return None


def list_connections() -> List[Connection]:
    """Return all connections stored in the ``SSH`` folder."""
    conns: List[Connection] = []
    if not is_unlocked():
        return conns
    folder_id = _get_ssh_folder_id()
    if folder_id is None:
        logging.error("Bitwarden folder 'SSH' not found")
        return conns
    data = _api_request(f"/ciphers?folderId={parse.quote(folder_id)}")
    if not data:
        return conns
    for item in data.get("data", []):
        login_data = item.get("login", {})
        username = login_data.get("username")
        uris = login_data.get("uris") or []
        uri = uris[0].get("uri") if uris else None
        if not (username and uri):
            continue
        label = item.get("name") or username
        conns.append(Connection(label=label, host=uri, username=username))
    return conns


def sync() -> Any:
    """Return the raw data from the ``/sync`` endpoint."""
    if not is_unlocked():
        return None
    url = f"{_server}/api/sync"
    req = request.Request(url)
    req.add_header("Authorization", f"Bearer {_token}")
    try:
        with request.urlopen(req) as resp:
            return json.loads(resp.read().decode())
    except error.URLError as exc:
        logging.error("Bitwarden sync request failed: %s", exc)
        return None
